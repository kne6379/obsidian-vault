---
created: 2026-02-05
updated: 2026-02-05
tags: [concept, os, cs]
status: done
---

# 프로세스와 스레드

> 프로세스는 운영체제로부터 자원을 할당받는 독립적 실행 단위이고, 스레드는 프로세스 내에서 자원을 공유하며 실행되는 흐름의 단위입니다.

---

## 1. 정의

### 프로세스 (Process)

운영체제로부터 자원을 할당받는 **작업의 단위**입니다. 실행 중인 프로그램을 의미하며, 완벽하게 독립적인 메모리 공간을 갖습니다.

### 스레드 (Thread)

프로세스 내에서 실제로 실행되는 **흐름의 단위**입니다. 하나의 프로세스는 최소 하나의 스레드를 가지며, 여러 스레드가 자원을 공유하면서 동시에 실행될 수 있습니다.

---

## 2. 메모리 구조 비교

### 프로세스의 메모리 구조

각 프로세스는 독립된 주소 공간을 할당받습니다:

```
┌─────────────────┐
│     Stack       │  ← 지역 변수, 함수 호출
├─────────────────┤
│       ↓         │
│                 │
│       ↑         │
├─────────────────┤
│     Heap        │  ← 동적 할당 메모리
├─────────────────┤
│     Data        │  ← 전역 변수, 정적 변수
├─────────────────┤
│     Code        │  ← 실행 코드
└─────────────────┘
```

### 스레드의 메모리 구조

스레드는 프로세스의 자원을 공유하되, **Stack만 독립적**으로 가집니다:

```
┌─────────────────────────────────────┐
│           프로세스                   │
├─────────────────────────────────────┤
│  Code   │  Data   │      Heap       │  ← 공유
├─────────┴─────────┴─────────────────┤
│  Stack1  │  Stack2  │  Stack3       │  ← 스레드별 독립
│ (Thread1)│ (Thread2)│ (Thread3)     │
└─────────────────────────────────────┘
```

**스택이 독립적인 이유:** 각 스레드가 독립적인 함수 호출과 실행 흐름을 가지려면 자신만의 호출 스택이 필요합니다.

---

## 3. 핵심 차이점

| 구분 | 프로세스 | 스레드 |
|------|----------|--------|
| **정의** | 자원 할당의 단위 | 실행 흐름의 단위 |
| **메모리** | 독립적 주소 공간 | 프로세스 자원 공유 (스택 제외) |
| **생성 비용** | 높음 | 낮음 |
| **통신 방식** | IPC 필요 (복잡) | 공유 메모리 (간단) |
| **컨텍스트 스위칭** | 무거움 | 가벼움 |
| **장애 영향** | 다른 프로세스에 영향 없음 | 전체 프로세스에 영향 가능 |

---

## 4. 컨텍스트 스위칭

### 프로세스 컨텍스트 스위칭

주소 공간 자체가 바뀌므로 비용이 큽니다:

1. 현재 프로세스 상태 저장 (레지스터, PC 등)
2. **캐시 메모리 비우기 (Cache Flush)**
3. 새 프로세스의 주소 공간으로 전환
4. 새 프로세스 상태 복원
5. **캐시 다시 채우기 (Cache Warm-up)**

→ "이사"에 비유될 만큼 오버헤드가 큽니다.

### 스레드 컨텍스트 스위칭

공유 자원은 그대로 두고 실행 흐름만 전환합니다:

1. 현재 스레드의 스택/레지스터 저장
2. 새 스레드의 스택/레지스터 복원

→ 캐시를 비울 필요 없어 훨씬 빠릅니다.

---

## 5. 멀티프로세스 vs 멀티스레드

### 멀티프로세스

```
┌──────────┐  ┌──────────┐  ┌──────────┐
│Process 1 │  │Process 2 │  │Process 3 │
│ (독립)   │  │ (독립)   │  │ (독립)   │
└──────────┘  └──────────┘  └──────────┘
     ↑              ↑              ↑
     └──────── IPC 통신 ───────────┘
```

**장점:**
- 하나가 죽어도 다른 프로세스에 영향 없음
- 안정성이 중요한 경우 적합 (크롬 브라우저 탭)

**단점:**
- 통신 비용 높음
- 컨텍스트 스위칭 비용 높음

### 멀티스레드

```
┌─────────────────────────────────┐
│           Process               │
│  ┌────────┬────────┬────────┐  │
│  │Thread 1│Thread 2│Thread 3│  │
│  └────────┴────────┴────────┘  │
│        (자원 공유)              │
└─────────────────────────────────┘
```

**장점:**
- 자원 공유로 효율적
- 통신 비용 낮음
- 컨텍스트 스위칭 빠름

**단점:**
- 하나의 스레드 문제가 전체에 영향
- 동기화 문제 (Race Condition, Deadlock)

---

## 6. 동기화 문제

멀티스레드에서 공유 자원 접근 시 발생하는 문제들:

### Race Condition

여러 스레드가 동시에 공유 자원을 수정할 때 결과가 예측 불가능해지는 현상입니다.

```java
// 문제: count++가 원자적이지 않음
class Counter {
    int count = 0;
    void increment() { count++; }
}
```

### 해결 방법

| 방법 | 설명 |
|------|------|
| **Mutex** | 상호 배제, 한 번에 하나의 스레드만 접근 |
| **Semaphore** | 동시 접근 가능한 스레드 수 제한 |
| **Monitor** | 언어 레벨에서 제공하는 동기화 (Java synchronized) |

---

## 7. 실무 적용

### 프로세스가 적합한 경우

- 작업 간 완전한 격리가 필요할 때
- 하나의 작업 실패가 다른 작업에 영향을 주면 안 될 때
- 예: 브라우저 탭, 마이크로서비스

### 스레드가 적합한 경우

- 자원 공유가 필요하고 빈번한 통신이 있을 때
- 빠른 응답이 필요할 때
- 예: 웹 서버 요청 처리, GUI 애플리케이션

---

## 관련 문서

- [[ECS]] - 컨테이너 기반 프로세스 관리
- [[Docker]] - 프로세스 격리 기술

---

## 참고 자료

- [메모리구조 관점에서 프로세스와 쓰레드 비교](https://www.youtube.com/watch?v=gQ4c6IzhU9Q) - 개발자 면접 영상
