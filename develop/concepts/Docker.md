---
created: 2026-02-01
updated: 2026-02-01
tags: [concept, devops, docker, container]
status: done
---

# Docker

> 애플리케이션을 컨테이너라는 표준화된 단위로 패키징하여 어떤 환경에서도 동일하게 실행할 수 있게 해주는 오픈소스 컨테이너화 플랫폼입니다.

---

## 1. 정의

Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 오픈 소스 컨테이너화 플랫폼입니다. 소프트웨어를 라이브러리, 시스템 도구, 코드, 런타임 등 실행에 필요한 모든 환경과 함께 '[[GLOSSARY#컨테이너|컨테이너]]'라는 표준화된 단위로 패키징하여, 어떤 환경에서도 동일하게 실행되도록 지원합니다.

---

## 2. 등장 배경 및 필요성

### 기존 가상화(VM)와의 차이

Docker의 개념을 이해하기 위해서는 기존의 하이퍼바이저 기반 가상머신과의 차이를 이해하는 것이 중요합니다.

**가상머신 (Virtual Machine)**
- 하드웨어 위에 하이퍼바이저를 설치하고, 그 위에 게스트 OS를 포함한 가상 머신을 구동합니다.
- 각 가상 머신마다 독립된 OS가 실행되므로 시스템 리소스(CPU, 메모리, 디스크) 소모가 크고 부팅 속도가 느립니다.
- 완벽한 격리가 가능하나 무겁다는 단점이 있습니다.

**Docker 컨테이너**
- 호스트 OS의 커널을 공유하며, 프로세스 단위로 격리된 환경을 제공합니다.
- 게스트 OS가 필요 없으므로 이미지 용량이 작고, 구동 속도가 매우 빠릅니다(밀리초 단위).
- 가볍고 효율적이며, 시스템 리소스 활용도가 높습니다.

---

## 3. 작동 원리 / 핵심 개념

### 3.1 Docker Engine

컨테이너를 생성하고 관리하는 핵심 런타임으로, 다음 세 가지 요소로 구성됩니다.

| 구성 요소 | 역할 |
|-----------|------|
| **Docker Daemon (dockerd)** | 백그라운드에서 실행되며 이미지, 컨테이너, 네트워크, 볼륨 등 Docker 객체를 관리합니다. |
| **Docker API** | Daemon과 통신하기 위한 REST API입니다. CLI나 외부 도구가 이 API를 통해 Docker를 제어합니다. |
| **Docker CLI** | 사용자가 명령어를 입력하는 인터페이스입니다. `docker run`, `docker build` 등의 명령어가 API를 통해 Daemon에 전달됩니다. |

**동작 흐름:** 사용자 명령(CLI) → Docker API → Docker Daemon → 컨테이너 생성/관리

### 3.2 핵심 구성 요소

**도커 이미지 (Docker Image)**

컨테이너를 실행하기 위해 필요한 파일, 설정, 종속성 등을 모두 포함한 읽기 전용 템플릿입니다. 상태 값을 가지지 않으며, 이 이미지를 실행하면 컨테이너가 생성됩니다.

Docker 이미지는 단일 파일이 아니라 여러 개의 읽기 전용 레이어가 쌓인 구조입니다. Dockerfile의 각 명령어(RUN, COPY, ADD)가 실행될 때마다 새로운 레이어가 생성되며, 각 레이어는 이전 레이어 대비 변경된 파일만 저장합니다.

레이어 구조의 이점:
- **저장 공간 절약:** 여러 이미지가 동일한 베이스 레이어를 공유할 수 있습니다.
- **빌드 속도 향상:** 변경되지 않은 레이어는 캐시에서 재사용합니다.
- **배포 효율성:** 이미지 업데이트 시 변경된 레이어만 다운로드합니다.

**도커 컨테이너 (Docker Container)**

도커 이미지가 실행되어 메모리에 로드된 상태입니다. 격리된 공간에서 프로세스가 실행되며, 파일 시스템과 네트워크 등이 호스트와 분리되어 있습니다. 컨테이너 실행 시 이미지 레이어 위에 쓰기 가능한 컨테이너 레이어가 추가됩니다.

**도커파일 (Dockerfile)**

도커 이미지를 생성하기 위한 설정 파일입니다. 어떤 베이스 이미지를 사용할지, 어떤 소프트웨어를 설치할지, 어떤 파일을 복사할지 등을 스크립트 형태로 정의합니다. 이를 통해 인프라 구성을 코드로 관리할 수 있습니다.

**도커 레지스트리 (Docker Registry)**

도커 이미지를 저장하고 배포하는 저장소입니다. 공개 저장소인 Docker Hub가 대표적이며, 사내 보안을 위해 비공개 레지스트리를 구축하여 사용할 수도 있습니다.

**도커 볼륨 (Docker Volume)**

컨테이너는 기본적으로 삭제되면 내부 데이터도 함께 사라집니다. 데이터를 영속적으로 보존하려면 볼륨을 사용해야 합니다.

| 방식 | 설명 | 사용 시점 |
|------|------|----------|
| **볼륨 (Volume)** | Docker가 관리하는 저장 영역에 데이터 저장 | 프로덕션 환경, 데이터베이스 등 **(권장)** |
| **바인드 마운트** | 호스트의 특정 경로를 컨테이너에 직접 마운트 | 로컬 개발 환경에서 소스 코드 실시간 반영 시 |
| **tmpfs 마운트** | 호스트 메모리에만 데이터 저장 | 민감 정보나 임시 데이터 처리 시 |

### 3.3 구성 요소 간 워크플로우

```
Dockerfile  →  (docker build)  →  이미지  →  (docker run)  →  컨테이너
                                    ↓
                              레지스트리에 push/pull
```

1. **Dockerfile 작성:** 애플리케이션 환경을 코드로 정의
2. **이미지 빌드:** `docker build` 명령으로 Dockerfile을 기반으로 이미지 생성
3. **이미지 배포:** Docker Hub 등 레지스트리에 push하여 공유
4. **컨테이너 실행:** `docker run` 명령으로 이미지를 기반으로 컨테이너 생성 및 실행

---

## 4. 장점 및 이점

- **이식성 및 일관성:** "한 번 빌드하면 어디서나 실행된다"는 원칙에 따라, 개발 환경, 테스트 환경, 운영 환경의 불일치 문제를 해결합니다.

- **효율적인 리소스 사용:** 별도의 OS를 포함하지 않으므로 가상머신 대비 훨씬 적은 용량과 메모리를 차지하며, 하나의 서버에 더 많은 애플리케이션을 구동할 수 있습니다.

- **신속한 배포 및 확장:** 컨테이너의 생성과 종료가 매우 빠르기 때문에 트래픽 변화에 따른 오토 스케일링이나 무중단 배포에 유리합니다.

- **마이크로서비스 아키텍처(MSA) 적합성:** 각 서비스를 독립된 컨테이너로 분리하여 개발 및 운영할 수 있어, 서비스 간 결합도를 낮추고 유지보수성을 높이는 데 최적화되어 있습니다.

---

## 5. 한계점 및 고려사항

- **보안 고려:** 컨테이너는 호스트 커널을 공유하므로, VM에 비해 격리 수준이 낮습니다. 민감한 워크로드의 경우 추가적인 보안 조치가 필요합니다.

- **상태 관리:** 컨테이너는 기본적으로 무상태(Stateless)로 설계되어 있어, 상태가 필요한 애플리케이션(데이터베이스 등)은 볼륨 관리에 주의가 필요합니다.

- **네트워크 복잡성:** 컨테이너 간 통신, 외부 네트워크 연결 등 네트워크 구성이 복잡해질 수 있습니다.

- **오케스트레이션 필요:** 대규모 컨테이너 환경에서는 Kubernetes와 같은 오케스트레이션 도구가 필요합니다.

---

## 6. 실무 적용 가이드

### 6.1 Docker Compose

여러 컨테이너를 하나의 애플리케이션으로 정의하고 관리하는 도구입니다.

**사용 목적:**
- 웹 서버, 데이터베이스, 캐시 등 여러 서비스로 구성된 애플리케이션을 단일 명령어로 실행/중지
- `docker-compose.yml` 파일에 서비스 구성을 선언적으로 정의
- 서비스 간 네트워크, 볼륨, 환경 변수 등을 일괄 설정

**예시 (docker-compose.yml):**

```yaml
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  db:
    image: postgres
    volumes:
      - db-data:/var/lib/postgresql/data
volumes:
  db-data:
```

**주요 명령어:**
- `docker-compose up`: 모든 서비스 시작
- `docker-compose down`: 모든 서비스 중지 및 삭제
- `docker-compose logs`: 서비스 로그 확인

### 6.2 다음 학습 단계

- **Docker와 Kubernetes의 관계:** 단일 컨테이너 관리는 Docker로 충분하나, 다수의 컨테이너를 오케스트레이션하려면 Kubernetes가 필요합니다.

---

## 관련 문서

- [[ECS]] - AWS에서 Docker 컨테이너를 오케스트레이션하는 관리형 서비스
- [[RAG]] - RAG 시스템을 Docker 컨테이너로 배포 시 참고

---

## 참고 자료

- [Docker 공식 문서](https://docs.docker.com/) - 공식 레퍼런스
- [Docker Hub](https://hub.docker.com/) - 공식 이미지 레지스트리
