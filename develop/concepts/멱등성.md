---
created: 2026-02-19
updated: 2026-02-19
tags: [concept, backend, api, database, architecture]
status: done
---

# 멱등성

> 동일한 연산을 여러 번 수행해도 결과가 한 번 수행한 것과 동일한 성질로, 분산 시스템에서 안전한 재시도와 데이터 일관성을 보장하는 핵심 설계 원칙입니다.

---

## 1. 정의

### 1.1 수학적 기원

멱등성(Idempotency)이라는 용어는 1870년 미국 수학자 벤저민 퍼스(Benjamin Peirce)가 도입하였습니다. 라틴어 'idem(같은)'과 'potence(힘)'의 합성어로, "같은 힘을 가진다"라는 의미입니다.

수학에서 멱등성은 어떤 연산을 여러 번 적용해도 한 번 적용한 것과 같은 결과를 내는 성질을 의미합니다.

```
f(f(x)) = f(x)
```

대표적인 예로 절댓값 함수가 있습니다. `abs(abs(-5)) = abs(-5) = 5`처럼 몇 번을 적용해도 결과가 동일합니다. 집합론에서는 합집합과 교집합 연산이 멱등적입니다. `A ∪ A = A`, `A ∩ A = A`가 항상 성립합니다.

### 1.2 컴퓨터 과학에서의 정의

컴퓨터 과학에서 멱등성은 맥락에 따라 두 가지로 구분됩니다.

- **명령형 프로그래밍**: 부수 효과(Side Effect)를 가진 서브루틴을 여러 번 호출해도 시스템 상태가 한 번 호출한 것과 동일한 성질
- **함수형 프로그래밍**: 순수 함수가 수학적 의미에서 멱등적인 성질, 즉 `f(f(x)) = f(x)`를 만족하는 성질

실무에서는 주로 명령형 프로그래밍 관점의 정의를 사용합니다. 핵심은 **응답이 아닌 시스템 상태의 변화**를 기준으로 판단한다는 것입니다. 동일한 요청을 10번 보내도 시스템 상태가 1번 보낸 것과 같다면, 그 연산은 멱등적입니다.

---

## 2. 등장 배경 및 필요성

### 2.1 분산 시스템의 본질적 불확실성

현대 시스템은 단일 서버가 아닌 수십~수백 개의 서비스가 네트워크로 연결된 분산 환경에서 동작합니다. 이 환경에서는 다음과 같은 장애가 일상적으로 발생합니다.

- **네트워크 타임아웃**: 요청은 도달했지만 응답이 돌아오지 않는 경우
- **부분 장애**: 전체 시스템 중 일부 서비스만 장애가 발생하는 경우
- **중복 전달**: 메시지 브로커가 동일한 메시지를 두 번 이상 전달하는 경우

클라이언트가 요청을 보낸 후 타임아웃이 발생하면, 서버가 요청을 처리했는지 여부를 알 수 없습니다. 이때 재시도하지 않으면 데이터 불일치가 발생하고, 재시도하면 중복 처리가 발생할 수 있습니다.

### 2.2 재시도 로직의 필수화

분산 시스템에서 재시도는 선택이 아닌 필수입니다. AWS에서는 "검증 오류가 아닌 모든 오류는 재시도로 극복할 수 있다"는 계약을 클라이언트에 제공하는 것을 권장합니다. 재시도가 안전하려면 연산이 멱등적이어야 합니다.

### 2.3 비즈니스 영향

멱등성 미보장 시 발생할 수 있는 실제 문제들입니다.

- **결제 이중 청구**: 고객에게 동일 금액이 두 번 과금
- **재고 이중 차감**: 한 건의 주문으로 재고가 두 번 감소
- **알림 중복 발송**: 동일 메시지가 여러 번 전송
- **데이터 정합성 훼손**: 집계/통계 데이터가 실제와 불일치

---

## 3. 핵심 개념

### 3.1 HTTP 메서드별 멱등성

RFC 9110(기존 RFC 7231의 후속)에서는 HTTP 메서드의 멱등성을 다음과 같이 정의합니다. "동일한 요청을 여러 번 보낸 의도된 효과가 한 번 보낸 것과 같으면 해당 메서드는 멱등적이다."

| 메서드 | 멱등성 | 안전성 | 설명 |
|--------|--------|--------|------|
| GET | O | O | 데이터 조회만 수행하며 서버 상태를 변경하지 않음 |
| HEAD | O | O | GET과 동일하나 응답 본문 없이 헤더만 반환 |
| PUT | O | X | 리소스 전체를 대체하므로 동일 요청의 반복은 같은 결과를 만듦 |
| DELETE | O | X | 리소스 삭제 후 재삭제 시 이미 없는 상태이므로 상태 변화 없음 |
| OPTIONS | O | O | 서버가 지원하는 메서드 목록을 반환 |
| POST | X | X | 호출할 때마다 새 리소스를 생성할 수 있어 본질적으로 비멱등적 |
| PATCH | X | X | 부분 수정의 의미론에 따라 멱등적일 수도, 아닐 수도 있음 |

**PATCH의 멱등성에 대한 보충 설명**

PATCH는 구현 방식에 따라 멱등성 여부가 달라집니다.

```json
// 멱등적: 값을 특정 상태로 설정
{ "op": "replace", "path": "/balance", "value": 100 }

// 비멱등적: 값을 증분
{ "op": "add", "path": "/balance", "value": 10 }
```

값을 특정 상태로 설정하는 연산은 여러 번 수행해도 결과가 동일하므로 멱등적입니다. 반면 증분 연산은 호출 횟수에 따라 결과가 달라지므로 비멱등적입니다.

**DELETE의 멱등성에 대한 보충 설명**

DELETE는 멱등적이지만, 응답 코드는 달라질 수 있습니다. 첫 번째 호출에서 `200 OK`를 반환하고 이후 호출에서 `404 Not Found`를 반환할 수 있습니다. 멱등성은 응답이 아닌 서버 상태를 기준으로 판단하므로, 이 경우에도 멱등적입니다.

### 3.2 멱등성 키 패턴

본질적으로 비멱등적인 POST 요청을 멱등적으로 만들기 위해 멱등성 키 패턴을 사용합니다.

**동작 원리**

1. 클라이언트가 고유한 멱등성 키(UUID v4 등)를 생성합니다
2. 요청 헤더에 `Idempotency-Key: <고유값>`을 포함하여 서버에 전송합니다
3. 서버는 해당 키로 이전 처리 이력을 조회합니다
4. 최초 요청이면 정상 처리 후 키, 요청 페이로드, 응답을 저장합니다
5. 중복 요청이면 저장된 응답을 그대로 반환합니다

**서버 측 저장소 구조**

```
idempotency_keys 테이블
├── key (PK)          -- 멱등성 키
├── request_hash      -- 요청 페이로드 해시 (변조 감지)
├── status            -- processing | completed | failed
├── response_code     -- HTTP 상태 코드
├── response_body     -- 응답 본문
├── created_at        -- 생성 시각
└── expires_at        -- 만료 시각
```

**IETF 표준화 동향**

IETF HTTPAPI 워킹 그룹에서 `Idempotency-Key` HTTP 헤더 필드를 표준화하고 있습니다. 현재 draft-ietf-httpapi-idempotency-key-header-07 단계이며, 표준 트랙(Standards Track)으로 진행 중입니다. 이 표준은 Stripe, PayPal 등 주요 결제 서비스의 멱등성 패턴에서 영감을 받았습니다.

**키 만료 정책**

멱등성 키는 영구 보관하지 않으며, 일반적으로 24시간~48시간 후 만료시킵니다. Stripe의 경우 24시간 후 키를 제거하며, 만료된 키로 동일 요청이 들어오면 새로운 요청으로 처리합니다.

### 3.3 데이터베이스 관점의 멱등성

#### UPSERT

UPSERT(INSERT or UPDATE)는 데이터베이스 수준에서 멱등성을 보장하는 대표적인 방법입니다. 레코드가 존재하면 갱신하고, 존재하지 않으면 삽입합니다.

```sql
-- PostgreSQL
INSERT INTO orders (order_id, amount, status)
VALUES ('ord-123', 50000, 'pending')
ON CONFLICT (order_id)
DO UPDATE SET amount = EXCLUDED.amount, status = EXCLUDED.status;

-- MySQL
INSERT INTO orders (order_id, amount, status)
VALUES ('ord-123', 50000, 'pending')
ON DUPLICATE KEY UPDATE amount = VALUES(amount), status = VALUES(status);
```

동일한 `order_id`로 10번 실행해도 결과는 한 번 실행한 것과 같습니다.

#### 유니크 제약 조건

유니크 제약을 통해 중복 삽입 자체를 차단하는 방법입니다.

```sql
-- 중복 삽입 시도 시 무시
INSERT INTO payment_events (idempotency_key, amount, created_at)
VALUES ('pay-key-abc', 50000, NOW())
ON CONFLICT (idempotency_key) DO NOTHING;
```

#### 낙관적 동시성 제어

버전 번호나 ETag를 활용하여 동시 수정을 감지하고 멱등성을 보장합니다.

```sql
UPDATE products
SET stock = stock - 1, version = version + 1
WHERE product_id = 'prod-123' AND version = 5;
-- 영향받은 행이 0이면 이미 다른 트랜잭션에서 수정된 것
```

#### 비관적 잠금

분산 환경에서 동일 키에 대한 동시 처리를 방지합니다.

```sql
-- MySQL InnoDB: 행 수준 잠금
SELECT * FROM idempotency_keys
WHERE key = 'pay-key-abc'
FOR UPDATE;
```

`SELECT ... FOR UPDATE`는 트랜잭션이 커밋 또는 롤백될 때까지 다른 세션의 동일 행 접근을 차단합니다.

### 3.4 메시지 큐에서의 멱등성

메시지 기반 아키텍처에서 전달 보장 수준은 세 가지로 구분됩니다.

| 전달 보장 | 설명 | 중복 가능성 | 유실 가능성 |
|-----------|------|:-----------:|:-----------:|
| 최대 1회(At-Most-Once) | 메시지를 최대 한 번 전달 | X | O |
| 최소 1회(At-Least-Once) | 메시지를 최소 한 번 전달 | O | X |
| 정확히 1회(Exactly-Once) | 메시지를 정확히 한 번 전달 | X | X |

대부분의 메시지 브로커(Kafka, RabbitMQ, SQS 등)는 기본적으로 최소 1회 전달을 보장합니다. 네트워크 장애, 자동 재전송, 지연된 ACK 등으로 동일 메시지가 두 번 이상 전달될 수 있습니다.

**멱등적 소비자 패턴**

최소 1회 전달 환경에서 멱등성을 확보하는 방법은 소비자 측에서 중복을 감지하고 처리하는 것입니다.

```
1. 메시지 수신
2. 메시지 ID로 처리 이력 조회
3. 이미 처리된 메시지라면 → 무시(ACK만 전송)
4. 미처리 메시지라면 → 비즈니스 로직 수행 + 메시지 ID 저장 (단일 트랜잭션)
5. ACK 전송
```

비즈니스 로직 수행과 메시지 ID 저장을 단일 트랜잭션으로 묶는 것이 핵심입니다. 이를 통해 최소 1회 전달 + 멱등적 소비자 = 정확히 1회 처리 효과를 달성합니다.

**카프카(Kafka)의 멱등적 프로듀서**

카프카 0.11 버전부터 멱등적 프로듀서 기능을 제공합니다.

```properties
enable.idempotence=true
```

브로커가 프로듀서 ID(PID)와 시퀀스 번호를 추적하여, 동일 메시지의 중복 전달을 방지합니다. 다만 프로듀서 재시작 시에는 새로운 PID가 할당되므로, 여러 파티션에 걸친 원자적 쓰기가 필요한 경우에는 트랜잭션 API(`transactional.id`, `beginTransaction()`, `commitTransaction()`)를 함께 사용해야 합니다.

---

## 4. 장점 및 이점

- **안전한 재시도**: 네트워크 장애 시 클라이언트가 동일 요청을 재전송해도 부작용이 없으므로, 재시도 로직을 단순하게 구현할 수 있습니다
- **데이터 일관성 보장**: 중복 처리로 인한 데이터 불일치를 방지하여 시스템의 정합성을 유지합니다
- **클라이언트 코드 단순화**: 클라이언트가 요청 성공 여부를 확인하지 못한 상황에서도 안전하게 재시도할 수 있어, 오류 처리 로직이 간결해집니다
- **시스템 복원력 향상**: 장애 복구 시 동일 작업을 재실행해도 상태가 올바르게 유지되므로, 장애 허용 시스템 설계가 용이합니다
- **사용자 경험 개선**: 이중 결제, 중복 주문 등 사용자가 체감하는 오류를 방지합니다
- **운영 비용 절감**: 중복 처리로 인한 수동 보정 작업(환불, 데이터 정리 등)이 감소합니다

---

## 5. 한계점 및 고려사항

- **저장소 비용**: 멱등성 키와 응답을 저장하기 위한 추가 저장소가 필요하며, 대용량 트래픽 환경에서는 저장소 크기 관리가 부담이 될 수 있습니다
- **성능 오버헤드**: 모든 요청에 대해 중복 여부를 조회하는 추가 연산이 발생합니다. 인메모리 캐시(Redis 등)를 활용하여 조회 성능을 확보하는 것이 일반적입니다
- **키 만료 정책 설계**: 멱등성 키의 보관 기간을 결정해야 합니다. 너무 짧으면 보장 범위가 줄어들고, 너무 길면 저장소 비용이 증가합니다
- **분산 환경의 동시성**: 동일 멱등성 키로 동시에 여러 요청이 도달할 수 있으며, 이 경우 분산 락이나 데이터베이스 수준의 잠금이 필요합니다
- **무상태 아키텍처와의 충돌**: 멱등성 보장을 위해 상태(처리 이력)를 저장해야 하므로, 완전한 무상태 설계와 상충됩니다
- **지연 도착 요청 처리**: 키가 만료된 후 지연된 재시도 요청이 도착하면 새로운 요청으로 처리될 수 있습니다. AWS는 이 경우에도 최초 응답과 의미적으로 동등한 응답을 반환하는 '최소 놀라움 원칙'을 적용합니다
- **모든 연산에 적합하지 않음**: 카운터 증분, 로그 기록 등 본질적으로 비멱등적인 연산을 멱등적으로 만들려면 설계를 근본적으로 변경해야 합니다

---

## 6. 실무 적용 가이드

### 6.1 결제 API

결제 시스템은 멱등성이 가장 절실히 요구되는 영역입니다. 이중 과금은 고객 신뢰를 직접적으로 훼손합니다.

**Stripe의 접근 방식**

Stripe는 모든 POST 요청에 `Idempotency-Key` 헤더를 지원합니다. 클라이언트가 UUID를 생성하여 헤더에 포함하면, 서버는 해당 키의 최초 요청 결과(성공/실패 모두 포함)를 저장하고, 동일 키의 후속 요청에는 저장된 결과를 반환합니다.

```
POST /v1/charges
Idempotency-Key: 8a39f4b2-c5d7-4e01-9f83-7a4b2c8d1e56
Content-Type: application/json

{
  "amount": 50000,
  "currency": "krw",
  "source": "tok_visa"
}
```

이 설계에서 핵심 원칙은 다음과 같습니다.

1. 실패한 요청도 저장하여 일관된 결과를 반환합니다
2. 재시도 시 요청 페이로드가 다르면 오류를 반환합니다
3. 키는 24시간 후 자동 만료됩니다
4. 클라이언트는 네트워크 오류 시 지수 백오프(Exponential Backoff) 전략으로 재시도합니다

### 6.2 배치 처리

배치 처리에서 멱등성은 작업의 중간 실패 후 재실행 시 데이터 정합성을 보장합니다.

**UPSERT 기반 배치 처리**

```sql
-- 1000건의 데이터를 배치로 적재할 때
-- 500건 처리 후 장애 발생 → 전체 재실행해도 안전
INSERT INTO daily_statistics (date, metric_key, value)
VALUES
  ('2026-02-19', 'active_users', 1523),
  ('2026-02-19', 'page_views', 45210),
  ...
ON CONFLICT (date, metric_key)
DO UPDATE SET value = EXCLUDED.value;
```

**데이터 파이프라인의 멱등성**

데이터 파이프라인에서는 각 처리 단계를 멱등적으로 설계하여, 파이프라인의 임의 지점에서 재실행해도 최종 결과가 올바르도록 보장합니다. 원천 데이터에서 결과를 재계산하는 방식으로 설계하면 자연스럽게 멱등성이 확보됩니다.

### 6.3 주문 처리 시스템

```
1. 클라이언트: 주문 ID(UUID)를 생성하여 주문 요청에 포함
2. 서버: 주문 ID로 orders 테이블에 UPSERT
3. 결제: 주문 ID를 멱등성 키로 사용하여 결제 API 호출
4. 재고: 주문 ID 기반 유니크 제약으로 이중 차감 방지
5. 알림: 처리된 메시지 ID를 기록하여 중복 알림 방지
```

전체 흐름에서 주문 ID가 멱등성 키 역할을 수행하며, 각 단계가 독립적으로 멱등성을 보장합니다. 어느 단계에서 장애가 발생해도 재시도가 안전합니다.

### 6.4 설계 원칙 요약

1. **처음부터 설계에 반영**: 멱등성은 사후에 추가하기 어렵습니다. API 설계 단계에서부터 반영해야 합니다
2. **클라이언트가 키를 생성**: 멱등성 키는 클라이언트가 생성하여 서버에 전달합니다. 이로써 클라이언트가 재시도의 의도를 명시적으로 표현할 수 있습니다
3. **지수 백오프와 함께 사용**: 멱등적 연산이라도 재시도 시 지수 백오프를 적용하여 서버 부하를 관리합니다
4. **실패도 저장**: 멱등성 키에 대한 처리 결과는 성공/실패 모두 저장하여 일관된 응답을 보장합니다
5. **단일 트랜잭션으로 처리**: 비즈니스 로직 수행과 멱등성 키 저장을 하나의 트랜잭션으로 묶어 원자성을 확보합니다

---

## 관련 문서

- [[API Gateway]] - API 라우팅 및 공통 기능 처리 계층
- [[배치 서비스 아키텍처]] - 배치 처리 시스템 설계
- [[디자인 패턴 비교]] - Strategy, Factory 등 설계 패턴

---

## 참고 자료

- [Designing robust and predictable APIs with idempotency - Stripe](https://stripe.com/blog/idempotency) - Stripe의 멱등성 설계 철학
- [Making retries safe with idempotent APIs - AWS Builders' Library](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/) - AWS의 멱등성 API 설계 가이드
- [The Idempotency-Key HTTP Header Field - IETF Draft](https://datatracker.ietf.org/doc/draft-ietf-httpapi-idempotency-key-header/) - IETF 멱등성 키 헤더 표준화 초안
- [Implementing Stripe-like Idempotency Keys in Postgres - brandur.org](https://brandur.org/idempotency-keys) - PostgreSQL 기반 멱등성 키 구현
- [Mastering Idempotency: Building Reliable APIs - ByteByteGo](https://blog.bytebytego.com/p/mastering-idempotency-building-reliable) - 멱등성 설계 종합 가이드
- [Exactly-once Semantics is Possible: Here's How Apache Kafka Does it - Confluent](https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/) - 카프카의 정확히 1회 전달 구현
- [Idempotent Consumer Pattern - microservices.io](https://microservices.io/patterns/communication-style/idempotent-consumer.html) - 멱등적 소비자 패턴
